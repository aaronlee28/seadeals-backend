// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	dto "seadeals-backend/dto"

	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"

	model "seadeals-backend/model"

	repository "seadeals-backend/repository"
)

// WalletRepository is an autogenerated mock type for the WalletRepository type
type WalletRepository struct {
	mock.Mock
}

// ChangeWalletPinByEmail provides a mock function with given fields: tx, userID, sellerID, req
func (_m *WalletRepository) ChangeWalletPinByEmail(tx *gorm.DB, userID uint, sellerID uint, req *dto.ChangePinByEmailReq) (*model.Wallet, error) {
	ret := _m.Called(tx, userID, sellerID, req)

	var r0 *model.Wallet
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, uint, *dto.ChangePinByEmailReq) *model.Wallet); ok {
		r0 = rf(tx, userID, sellerID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Wallet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, uint, uint, *dto.ChangePinByEmailReq) error); ok {
		r1 = rf(tx, userID, sellerID, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOrder provides a mock function with given fields: tx, sellerID, voucherID, transactionID, userID
func (_m *WalletRepository) CreateOrder(tx *gorm.DB, sellerID uint, voucherID *uint, transactionID uint, userID uint) (*model.Order, error) {
	ret := _m.Called(tx, sellerID, voucherID, transactionID, userID)

	var r0 *model.Order
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, *uint, uint, uint) *model.Order); ok {
		r0 = rf(tx, sellerID, voucherID, transactionID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, uint, *uint, uint, uint) error); ok {
		r1 = rf(tx, sellerID, voucherID, transactionID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOrderItemAndRemoveFromCart provides a mock function with given fields: tx, productVariantDetailID, product, orderID, userID, quantity, subtotal, cartItem
func (_m *WalletRepository) CreateOrderItemAndRemoveFromCart(tx *gorm.DB, productVariantDetailID uint, product *model.Product, orderID uint, userID uint, quantity uint, subtotal float64, cartItem *model.CartItem) error {
	ret := _m.Called(tx, productVariantDetailID, product, orderID, userID, quantity, subtotal, cartItem)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, *model.Product, uint, uint, uint, float64, *model.CartItem) error); ok {
		r0 = rf(tx, productVariantDetailID, product, orderID, userID, quantity, subtotal, cartItem)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTransaction provides a mock function with given fields: tx, transaction
func (_m *WalletRepository) CreateTransaction(tx *gorm.DB, transaction *model.Transaction) (*model.Transaction, error) {
	ret := _m.Called(tx, transaction)

	var r0 *model.Transaction
	if rf, ok := ret.Get(0).(func(*gorm.DB, *model.Transaction) *model.Transaction); ok {
		r0 = rf(tx, transaction)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, *model.Transaction) error); ok {
		r1 = rf(tx, transaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWallet provides a mock function with given fields: _a0, _a1
func (_m *WalletRepository) CreateWallet(_a0 *gorm.DB, _a1 *model.Wallet) (*model.Wallet, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *model.Wallet
	if rf, ok := ret.Get(0).(func(*gorm.DB, *model.Wallet) *model.Wallet); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Wallet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, *model.Wallet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWalletTransaction provides a mock function with given fields: tx, walletID, transaction
func (_m *WalletRepository) CreateWalletTransaction(tx *gorm.DB, walletID uint, transaction *model.Transaction) error {
	ret := _m.Called(tx, walletID, transaction)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, *model.Transaction) error); ok {
		r0 = rf(tx, walletID, transaction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCartItem provides a mock function with given fields: tx, cartID
func (_m *WalletRepository) GetCartItem(tx *gorm.DB, cartID uint) (*model.CartItem, error) {
	ret := _m.Called(tx, cartID)

	var r0 *model.CartItem
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) *model.CartItem); ok {
		r0 = rf(tx, cartID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CartItem)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, uint) error); ok {
		r1 = rf(tx, cartID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionsByUserID provides a mock function with given fields: tx, userID
func (_m *WalletRepository) GetTransactionsByUserID(tx *gorm.DB, userID uint) ([]*model.Transaction, error) {
	ret := _m.Called(tx, userID)

	var r0 []*model.Transaction
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) []*model.Transaction); ok {
		r0 = rf(tx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, uint) error); ok {
		r1 = rf(tx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVoucher provides a mock function with given fields: tx, voucherCode
func (_m *WalletRepository) GetVoucher(tx *gorm.DB, voucherCode string) (*model.Voucher, error) {
	ret := _m.Called(tx, voucherCode)

	var r0 *model.Voucher
	if rf, ok := ret.Get(0).(func(*gorm.DB, string) *model.Voucher); ok {
		r0 = rf(tx, voucherCode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Voucher)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, string) error); ok {
		r1 = rf(tx, voucherCode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletByUserID provides a mock function with given fields: _a0, _a1
func (_m *WalletRepository) GetWalletByUserID(_a0 *gorm.DB, _a1 uint) (*model.Wallet, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *model.Wallet
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) *model.Wallet); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Wallet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, uint) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletStatus provides a mock function with given fields: tx, userID
func (_m *WalletRepository) GetWalletStatus(tx *gorm.DB, userID uint) (string, error) {
	ret := _m.Called(tx, userID)

	var r0 string
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) string); ok {
		r0 = rf(tx, userID)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, uint) error); ok {
		r1 = rf(tx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaginatedTransactions provides a mock function with given fields: tx, q, userID
func (_m *WalletRepository) PaginatedTransactions(tx *gorm.DB, q *repository.Query, userID uint) (int, []*model.Transaction, error) {
	ret := _m.Called(tx, q, userID)

	var r0 int
	if rf, ok := ret.Get(0).(func(*gorm.DB, *repository.Query, uint) int); ok {
		r0 = rf(tx, q, userID)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 []*model.Transaction
	if rf, ok := ret.Get(1).(func(*gorm.DB, *repository.Query, uint) []*model.Transaction); ok {
		r1 = rf(tx, q, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*model.Transaction)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*gorm.DB, *repository.Query, uint) error); ok {
		r2 = rf(tx, q, userID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RequestChangePinByEmail provides a mock function with given fields: userID, key, code
func (_m *WalletRepository) RequestChangePinByEmail(userID uint, key string, code string) error {
	ret := _m.Called(userID, key, code)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, string, string) error); ok {
		r0 = rf(userID, key, code)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StepUpPassword provides a mock function with given fields: tx, userID, password
func (_m *WalletRepository) StepUpPassword(tx *gorm.DB, userID uint, password string) error {
	ret := _m.Called(tx, userID, password)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, string) error); ok {
		r0 = rf(tx, userID, password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TopUp provides a mock function with given fields: tx, wallet, amount
func (_m *WalletRepository) TopUp(tx *gorm.DB, wallet *model.Wallet, amount float64) (*model.Wallet, error) {
	ret := _m.Called(tx, wallet, amount)

	var r0 *model.Wallet
	if rf, ok := ret.Get(0).(func(*gorm.DB, *model.Wallet, float64) *model.Wallet); ok {
		r0 = rf(tx, wallet, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Wallet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, *model.Wallet, float64) error); ok {
		r1 = rf(tx, wallet, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransactionDetails provides a mock function with given fields: tx, transactionID
func (_m *WalletRepository) TransactionDetails(tx *gorm.DB, transactionID uint) (*model.Transaction, error) {
	ret := _m.Called(tx, transactionID)

	var r0 *model.Transaction
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) *model.Transaction); ok {
		r0 = rf(tx, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gorm.DB, uint) error); ok {
		r1 = rf(tx, transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateOrder provides a mock function with given fields: tx, order
func (_m *WalletRepository) UpdateOrder(tx *gorm.DB, order *model.Order) error {
	ret := _m.Called(tx, order)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, *model.Order) error); ok {
		r0 = rf(tx, order)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStock provides a mock function with given fields: tx, productVariantDetail, newStock
func (_m *WalletRepository) UpdateStock(tx *gorm.DB, productVariantDetail *model.ProductVariantDetail, newStock uint) error {
	ret := _m.Called(tx, productVariantDetail, newStock)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, *model.ProductVariantDetail, uint) error); ok {
		r0 = rf(tx, productVariantDetail, newStock)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTransaction provides a mock function with given fields: tx, transaction
func (_m *WalletRepository) UpdateTransaction(tx *gorm.DB, transaction *model.Transaction) error {
	ret := _m.Called(tx, transaction)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, *model.Transaction) error); ok {
		r0 = rf(tx, transaction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateWallet provides a mock function with given fields: tx, userID, newBalance
func (_m *WalletRepository) UpdateWallet(tx *gorm.DB, userID uint, newBalance float64) error {
	ret := _m.Called(tx, userID, newBalance)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, float64) error); ok {
		r0 = rf(tx, userID, newBalance)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateWalletBalance provides a mock function with given fields: tx, wallet, totalTransaction
func (_m *WalletRepository) UpdateWalletBalance(tx *gorm.DB, wallet *model.Wallet, totalTransaction float64) error {
	ret := _m.Called(tx, wallet, totalTransaction)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, *model.Wallet, float64) error); ok {
		r0 = rf(tx, wallet, totalTransaction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateRequestByEmailCodeIsValid provides a mock function with given fields: userID, req
func (_m *WalletRepository) ValidateRequestByEmailCodeIsValid(userID uint, req *dto.CodeKeyRequestByEmailReq) error {
	ret := _m.Called(userID, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, *dto.CodeKeyRequestByEmailReq) error); ok {
		r0 = rf(userID, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateRequestIsValid provides a mock function with given fields: userID, key
func (_m *WalletRepository) ValidateRequestIsValid(userID uint, key string) error {
	ret := _m.Called(userID, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, string) error); ok {
		r0 = rf(userID, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateWalletPin provides a mock function with given fields: tx, userID, pin
func (_m *WalletRepository) ValidateWalletPin(tx *gorm.DB, userID uint, pin string) error {
	ret := _m.Called(tx, userID, pin)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, string) error); ok {
		r0 = rf(tx, userID, pin)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalletPin provides a mock function with given fields: tx, userID, pin
func (_m *WalletRepository) WalletPin(tx *gorm.DB, userID uint, pin string) error {
	ret := _m.Called(tx, userID, pin)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, string) error); ok {
		r0 = rf(tx, userID, pin)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewWalletRepository interface {
	mock.TestingT
	Cleanup(func())
}

// NewWalletRepository creates a new instance of WalletRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewWalletRepository(t mockConstructorTestingTNewWalletRepository) *WalletRepository {
	mock := &WalletRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
